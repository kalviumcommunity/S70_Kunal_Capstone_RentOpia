// TypeScript Version: 3.0
const fs = require('fs')
const path = require('path')
const os = require('os')
const crypto = require('crypto')
const packageJson = require('../package.json')

const version = packageJson.version

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

// Parse src into an Object
function parse (src) {
  const obj = {}

  let lines = src.toString()
  lines = lines.replace(/\r\n?/mg, '\n')

  let match
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1]
    let value = (match[2] || '').trim()
    const maybeQuote = value[0]
    value = value.replace(/^(["'`])([\s\S]*)\1$/mg, '$2')
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n').replace(/\\r/g, '\r')
    }
    obj[key] = value
  }

  return obj
}

function _vaultPath (options) {
  let possibleVaultPath = null

  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      for (const filepath of options.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`
        }
      }
    } else {
      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')
  }

  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath
  }
  return null
}

function _dotenvKey (options) {
  if (options?.DOTENV_KEY?.length > 0) return options.DOTENV_KEY
  if (process.env.DOTENV_KEY?.length > 0) return process.env.DOTENV_KEY
  return ''
}

function _instructions (result, dotenvKey) {
  let uri
  try {
    uri = new URL(dotenvKey)
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      const err = new Error('INVALID_DOTENV_KEY: Must be valid URI format')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    }
    throw error
  }

  const key = uri.password
  const environment = uri.searchParams.get('environment')
  const environmentKey = `DOTENV_VAULT_${environment?.toUpperCase()}`

  if (!key) throw new Error('INVALID_DOTENV_KEY: Missing key')
  if (!environment) throw new Error('INVALID_DOTENV_KEY: Missing environment')

  const ciphertext = result.parsed?.[environmentKey]
  if (!ciphertext) throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: ${environmentKey} not found`)

  return { ciphertext, key }
}

function _parseVault (options) {
  const vaultPath = _vaultPath(options)
  options.path = vaultPath
  const result = DotenvModule.configDotenv(options)
  if (!result.parsed) throw new Error(`MISSING_DATA: Cannot parse ${vaultPath}`)

  const keys = _dotenvKey(options).split(',')
  for (const key of keys) {
    try {
      const { ciphertext, key: decryptKey } = _instructions(result, key.trim())
      const decrypted = DotenvModule.decrypt(ciphertext, decryptKey)
      return DotenvModule.parse(decrypted)
    } catch {}
  }
  throw new Error('DECRYPTION_FAILED: All DOTENV_KEYs failed')
}

function _log (msg) {
  console.log(`[dotenv@${version}] ${msg}`)
}

function _debug (msg) {
  console.log(`[dotenv@${version}][DEBUG] ${msg}`)
}

function _warn (msg) {
  console.log(`[dotenv@${version}][WARN] ${msg}`)
}

function _resolveHome (envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath
}

function configDotenv (options) {
  const dotenvPath = path.resolve(process.cwd(), '.env')
  const encoding = options?.encoding || 'utf8'
  const debug = Boolean(options?.debug)
  const quiet = Boolean(options?.quiet)
  let optionPaths = Array.isArray(options?.path) ? options.path.map(_resolveHome) : [_resolveHome(options?.path || dotenvPath)]

  const parsedAll = {}
  let lastError
  for (const filePath of optionPaths) {
    try {
      const parsed = DotenvModule.parse(fs.readFileSync(filePath, { encoding }))
      DotenvModule.populate(parsedAll, parsed, options)
    } catch (e) {
      if (debug) _debug(`Failed to load ${filePath} ${e.message}`)
      lastError = e
    }
  }

  const processEnv = options?.processEnv || process.env
  DotenvModule.populate(processEnv, parsedAll, options)

  if (debug || !quiet) {
    const keysCount = Object.keys(parsedAll).length
    const shortPaths = optionPaths.map(p => path.relative(process.cwd(), p))
    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')}`)
  }

  return lastError ? { parsed: parsedAll, error: lastError } : { parsed: parsedAll }
}

function _configVault (options) {
  const debug = Boolean(options?.debug)
  const quiet = Boolean(options?.quiet)
  if (debug || !quiet) _log('Loading env from encrypted .env.vault')

  const parsed = DotenvModule._parseVault(options)
  const processEnv = options?.processEnv || process.env
  DotenvModule.populate(processEnv, parsed, options)

  return { parsed }
}

function config (options) {
  if (_dotenvKey(options).length === 0) return DotenvModule.configDotenv(options)
  const vaultPath = _vaultPath(options)
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but are missing .env.vault at ${vaultPath}`)
    return DotenvModule.configDotenv(options)
  }
  return DotenvModule._configVault(options)
}

function decrypt (encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex')
  let ciphertext = Buffer.from(encrypted, 'base64')
  const nonce = ciphertext.subarray(0, 12)
  const authTag = ciphertext.subarray(-16)
  ciphertext = ciphertext.subarray(12, -16)

  try {
    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)
    aesgcm.setAuthTag(authTag)
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
  } catch (error) {
    const msg = error.message
    if (msg === 'Invalid key length') throw new Error('INVALID_DOTENV_KEY: Must be 64+ chars')
    if (msg === 'Unsupported state or unable to authenticate data') throw new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')
    throw error
  }
}

function populate (processEnv, parsed, options = {}) {
  const debug = Boolean(options.debug)
  const override = Boolean(options.override)

  if (typeof parsed !== 'object') throw new Error('OBJECT_REQUIRED: parsed must be an object')

  for (const key of Object.keys(parsed)) {
    const exists = Object.prototype.hasOwnProperty.call(processEnv, key)
    if (!exists || override) {
      processEnv[key] = parsed[key]
    }
    if (debug) {
      const msg = exists ? (override ? 'WAS overwritten' : 'was NOT overwritten') : 'set'
      _debug(`"${key}" ${msg}`)
    }
  }
}

const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
}

module.exports = DotenvModule
